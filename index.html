<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Magic Address Finder</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { font-family: Arial, sans-serif; margin:0; }
    #map { height: 460px; }
    .controls { padding:12px; display:grid; gap:10px; background:#f7f7f9; border-bottom:1px solid #e5e5ef; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row.wrap { align-items:flex-start; }
    label { font-weight:600; }
    input[type=text]{ padding:8px; min-width:260px; }
    input[type=range]{ width:280px; }
    .value{ font-weight:700; margin-left:6px; min-width:40px; text-align:right; }
    button{ padding:10px 16px; font-size:16px; cursor:pointer; border-radius:8px; border:1px solid #cfd2dc; background:white; }
    button:hover{ background:#f0f2f7; }
    .hint{ font-size:12px; color:#666; }
    .status { font-size:12px; color:#333; }
    .checkboxes { display:grid; grid-template-columns:repeat(4,minmax(140px,1fr)); gap:6px 16px; }
    .checkboxes label { font-weight:500; display:flex; gap:6px; align-items:center; }
    .section-title { font-weight:700; margin-right:6px; }
    .type-actions { display:flex; gap:8px; }
  </style>
</head>
<body>
  <div class="controls">
    <div class="row">
      <label for="cityInput">Search for a city:</label>
      <input type="text" id="cityInput" placeholder="Type a city..." />
      <button id="searchBtn">Search</button>
      <span class="hint">Tip: you can also click the map to set the point.</span>
    </div>

    <div class="row">
      <label for="radiusSlider">Radius (km):</label>
      <input type="range" id="radiusSlider" min="10" max="200" step="5" value="50" />
      <span class="value" id="radiusValue">50</span>
    </div>

    <div class="row">
      <label for="countSlider">Number of addresses:</label>
      <input type="range" id="countSlider" min="5" max="600" step="5" value="50" />
      <span class="value" id="countValue">50</span>
    </div>

    <div class="row wrap">
      <span class="section-title">Types:</span>
      <div class="checkboxes" id="typeChecks">
        <label><input type="checkbox" value="shop" checked />shop</label>
        <label><input type="checkbox" value="amenity" checked />amenity</label>
        <label><input type="checkbox" value="office" checked />office</label>
        <label><input type="checkbox" value="craft" checked />craft</label>
        <label><input type="checkbox" value="tourism" checked />tourism</label>
        <label><input type="checkbox" value="leisure" checked />leisure</label>
        <label><input type="checkbox" value="healthcare" checked />healthcare</label>
        <label><input type="checkbox" value="industrial" checked />industrial</label>
        <label><input type="checkbox" value="building" checked />building (retail/commercial/industrial)</label>
      </div>
      <div class="type-actions">
        <button id="btnAll">Select all</button>
        <button id="btnNone">Unselect all</button>
      </div>
    </div>

    <div class="row">
      <button id="magicBtn">Let's do the magic !</button>
    </div>

    <div class="status" id="status"></div>
    <div class="hint">OSM/Overpass (multi-mirrors). Belgium & Netherlands only. Valid postcodes required. Anonymized names.</div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // --- Overpass mirrors ---
    const OVERPASS_ENDPOINTS = [
      "https://overpass.kumi.systems/api/interpreter",
      "https://overpass-api.de/api/interpreter",
      "https://overpass.openstreetmap.ru/api/interpreter",
      "https://overpass.nchc.org.tw/api/interpreter",
      "https://maps.mail.ru/osm/tools/overpass/api/interpreter"
    ];

    // --- Map init ---
    const map = L.map('map').setView([50.85, 4.35], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap contributors' }).addTo(map);

    let marker = null, circle = null;

    const cityInput   = document.getElementById('cityInput');
    const searchBtn   = document.getElementById('searchBtn');
    const radiusSlider= document.getElementById('radiusSlider');
    const radiusValue = document.getElementById('radiusValue');
    const countSlider = document.getElementById('countSlider');
    const countValue  = document.getElementById('countValue');
    const magicBtn    = document.getElementById('magicBtn');
    const statusEl    = document.getElementById('status');
    const typeChecks  = document.getElementById('typeChecks');
    const btnAll      = document.getElementById('btnAll');
    const btnNone     = document.getElementById('btnNone');

    const kmToMeters = km => km * 1000;

    function drawCircle(centerLatLng) {
      const radiusMeters = kmToMeters(parseInt(radiusSlider.value, 10));
      if (circle) circle.remove();
      circle = L.circle(centerLatLng, { radius: radiusMeters, color: "#2563eb", fillOpacity: 0.08 }).addTo(map);
      map.fitBounds(circle.getBounds(), { padding: [20,20] });
    }
    function setPoint(latlng){ if (marker) marker.remove(); marker = L.marker(latlng).addTo(map); drawCircle(latlng); }
    map.on('click', e => setPoint(e.latlng));
    radiusSlider.addEventListener('input', () => { radiusValue.textContent = radiusSlider.value; if (marker) drawCircle(marker.getLatLng()); });
    countSlider .addEventListener('input', () => { countValue.textContent  = countSlider.value; });

    // Select all / none
    btnAll.addEventListener('click', () => { typeChecks.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = true); });
    btnNone.addEventListener('click', () => { typeChecks.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = false); });

    // City search just for centering
    async function searchCity(){
      const q = cityInput.value.trim(); if(!q){ alert("Please type a city."); return; }
      try{
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
        const data = await res.json();
        if(data && data.length>0){ const lat=+data[0].lat, lon=+data[0].lon; setPoint([lat,lon]); }
        else alert("City not found. Click on the map instead.");
      }catch{ alert("Search failed. Click on the map instead."); }
    }
    searchBtn.addEventListener('click', searchCity);
    cityInput.addEventListener('keydown', e => { if(e.key==='Enter') searchCity(); });

    // ---------- Creative anonymized names (unique & varied) ----------
    const SUFFIXES = ["Ltd.","Inc.","Co.","Group","Studio","Works","Collective","Company","House","Lab","Atelier"];
    const ANIMALS  = ["Fox","Bear","Wolf","Otter","Hawk","Sparrow","Raven","Falcon","Deer","Bison","Lynx","Badger","Hare","Bee","Crane","Heron","Seal","Dolphin"];
    const NUMWORDS = ["Two","Three","Five","Seven","Nine","Twelve","Fifteen","Twenty"];
    const COLORS   = ["Blue","Green","Crimson","Amber","Ivory","Indigo","Golden","Silver","Copper","Emerald","Azure","Scarlet","Violet","Teal","Cobalt"];
    const QUALS    = ["Urban","Northern","Grand","Quiet","Happy","Sunny","Clever","Brisk","Rapid","Mighty","Honest","True","Brave","Nimble","Prime"];
    const LEX = {
      "Bakery":     { cores:["Loaf","Crust","Oven","Pastry","Brioche","Bagel","Bakehouse","Bun","Mill","Flour","Yeast","Butter","Crumble","Croissant","Cracker"], ends:["Bakery","Bakehouse","Patisserie"] },
      "Bike Shop":  { cores:["Cycle","Wheel","Spoke","Chain","Sprocket","Pedal","Frame","Saddle","Gear","Gravel","Hub","Trail","Fixie","Velodrome","Cruiser"], ends:["Cycles","Bicycles","Bike Co."] },
      "Bookstore":  { cores:["Page","Chapter","Quill","Scroll","Library","Archive","Tome","Novel","Fable","Ink","Bookmark","Shelf","Edition","Folio","Volume"], ends:["Books","Bookshop","Press"] },
      "Pharmacy":   { cores:["Health","Remedy","Cure","Vial","Herb","Pill","Care","Vital","Wellness","Apothecary","Ointment","Serum","Dose","Clinic"], ends:["Pharmacy","Apothecary","Health"] },
      "Tech Store": { cores:["Pixel","Circuit","Quantum","Logic","Byte","Chip","Matrix","Vector","Nova","Photon","Cloud","Kernel","Module"], ends:["Labs","Tech","Systems"] },
      "Restaurant": { cores:["Fork","Skillet","Grill","Flame","Garden","Olive","Basil","Harvest","Pantry","Table","Spice","Smoke","Ember"], ends:["Kitchen","Bistro","Table"] },
      "Bar":        { cores:["Taproom","Barrel","Malt","Hop","Cask","Cellar","Stout","Ale","Wine","Tavern","Moon","Oak","Spirit","Lime","Salt"], ends:["Bar","Tavern","Club"] },
      "Gym":        { cores:["Muscle","Core","Pulse","Sprint","Power","Iron","Fit","Motion","Tempo","Zen","Focus","Arena","Peak","Summit"], ends:["Gym","Fitness","Athletics"] },
      "Music Shop": { cores:["Note","Chord","Melody","Rhythm","Groove","Harmony","Lyric","Tempo","Beat","Record","Vinyl","Guitar","Piano","Drum"], ends:["Music","Records","Sound"] },
      "Clothing":   { cores:["Thread","Loom","Needle","Silk","Denim","Wool","Cotton","Wardrobe","Closet","Button","Pattern","Tailor","Stitch","Hem","Lace"], ends:["Apparel","Outfitters","Clothiers"] },
      "Workshop":   { cores:["Workbench","Anvil","Forge","Hammer","Lathe","Chisel","Timber","Joinery","Resin","Fiber","Craft","Toolbox","Bench"], ends:["Works","Atelier","Fabrication"] },
      "Hotel":      { cores:["Harbor","Vista","Garden","Cedar","Maple","Riverside","Lakeside","Hilltop","Crescent","Orchid","Aurora","Lagoon","Beacon","Lodge"], ends:["Hotel","Inn","Suites"] },
      "Leisure":    { cores:["Arcade","Arena","Park","Playhouse","Meadow","Pavilion","Carousel","Bowling","Cinema","Skate","Rink","Lagoon","Pier"], ends:["Leisure","Center","Park"] },
      "Industrial": { cores:["Steel","Foundry","Alloy","Forge","Engine","Turbine","Assembly","Depot","Granite","Atlas","Crane","Anchor"], ends:["Industries","Works","Plant"] },
      "Office":     { cores:["Summit","Bridge","Harbor","Axis","Vista","Prime","Union","Pioneer","Anchor","Beacon","Sterling"], ends:["Office","Partners","Group"] },
      "Business":   { cores:["Corner","Market","Square","Union","Central","Prime","Anchor","Bridge","Compass","Atlas","Pioneer","Crown","Crescent"], ends:["Company","Group","Co."] }
    };
    const NAME_POOLS = {};
    function pick(a){ return a[Math.floor(Math.random()*a.length)]; }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function generatePool(sector, target=100){
      const spec = LEX[sector] || LEX["Business"];
      const out = new Set();
      while(out.size < target){
        const form = Math.floor(Math.random()*6);
        const adj = pick([...COLORS, ...QUALS]);
        const animal = pick(ANIMALS);
        const c1 = pick(spec.cores);
        const c2 = pick(spec.cores.filter(x => x!==c1));
        const end = pick(spec.ends);
        const num = pick(NUMWORDS);
        let name = "";
        switch(form){
          case 0: name = `${adj} ${c1} ${end}`; break;
          case 1: name = `${animal} ${c1} ${end}`; break;
          case 2: name = `${num} ${c1} ${end}`; break;
          case 3: name = `${c1} & ${c2} ${end}`; break;
          case 4: name = `${adj} ${animal} ${c1} ${end}`; break;
          case 5: name = `${c1} ${adj} ${end}`; break;
        }
        out.add(name.trim());
      }
      return shuffle([...out]);
    }
    function getPool(sector){
      if(!NAME_POOLS[sector]) NAME_POOLS[sector] = generatePool(sector, 100);
      return NAME_POOLS[sector];
    }
    function makeUniqueNameDispenser(){
      const used = new Set();
      return function next(sector){
        const pool = getPool(sector);
        while(pool.length){
          const n = pool.pop();
          if(!used.has(n)){ used.add(n); return n; }
        }
        // fallback if pool exhausted
        let base = `${pick(COLORS)} ${pick((LEX[sector]||LEX["Business"]).cores)} ${pick((LEX[sector]||LEX["Business"]).ends)}`;
        let i=2, cand=base;
        while(used.has(cand)){ cand = `${base} ${i} ${pick(SUFFIXES)}`; i++; }
        used.add(cand); return cand;
      };
    }
    const nextCreativeName = makeUniqueNameDispenser();

    // ---------- City extraction (robuste & multilingue) ----------
    function firstNonEmpty(tags, keys){
      for (const k of keys){ const v = tags[k]; if (v && String(v).trim()) return String(v).trim(); }
      return "";
    }
    function multiLangKeys(base){ const langs=["fr","nl","de","en"]; return [base, ...langs.map(l=>`${base}:${l}`)]; }
    function getCityFromTags(tags){
      const candidates = [
        ...multiLangKeys("addr:city"),
        ...multiLangKeys("addr:town"),
        ...multiLangKeys("addr:village"),
        ...multiLangKeys("addr:municipality"),
        "addr:suburb","addr:hamlet","addr:place",
        "is_in:city","is_in:town","is_in:municipality"
      ];
      return firstNonEmpty(tags, candidates);
    }

    // ---------- Postcode validation (BE & NL only) ----------
    function isValidPostcodeBE(pc){ return /^[1-9][0-9]{3}$/.test(pc); } // 1000â€“9999
    function isValidPostcodeNL(pc){ return /^[1-9][0-9]{3}\s?[A-Z]{2}$/.test(pc); } // 1012AB or 1012 AB
    function isValidBENLPostcode(pc){
      const x = (pc || "").toString().trim().toUpperCase();
      return isValidPostcodeBE(x) || isValidPostcodeNL(x);
    }

    // --- CSV helper
    function toCsv(rows){
      const esc=v=>{ const s=String(v??""); return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s; };
      return rows.map(r=>r.map(esc).join(",")).join("\n");
    }
    function updateStatus(msg){ statusEl.textContent = msg; }

    // --- Build & run Overpass queries (BE+NL areas, LIMIT, EARLY-STOP) ---
    function getSelectedTypes(){
      return Array.from(typeChecks.querySelectorAll("input[type=checkbox]"))
        .filter(cb => cb.checked).map(cb => cb.value);
    }

    // Overpass: restrict to Belgium & Netherlands via areas + require addr:street, housenumber, postcode
    function queryForKey(lat, lon, radiusMeters, key, limit){
      const R = Math.floor(radiusMeters);
      const LIM = Math.max(1, Math.min(300, limit|0));
      const addrFilter = '["addr:street"]["addr:housenumber"]["addr:postcode"]';
      const keyFilter  = key === "building"
        ? '["building"~"^(retail|commercial|industrial)$"]'
        : `["${key}"]`;

      return `
[out:json][timeout:60];
area["ISO3166-1"="BE"][admin_level=2]->.be;
area["ISO3166-1"="NL"][admin_level=2]->.nl;
(
  nwr(area.be)(around:${R},${lat},${lon})${keyFilter}${addrFilter};
  nwr(area.nl)(around:${R},${lat},${lon})${keyFilter}${addrFilter};
);
out tags center qt ${LIM};
      `;
    }

    async function overpassCall(query){
      const body = "data=" + encodeURIComponent(query);
      let lastErr;
      for (let i=0;i<OVERPASS_ENDPOINTS.length;i++){
        const ep = OVERPASS_ENDPOINTS[i];
        try{
          const res = await fetch(ep, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }, body });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return await res.json();
        }catch(e){
          lastErr = e;
          await new Promise(r => setTimeout(r, 500 * (i+1)));
        }
      }
      throw lastErr || new Error("All Overpass mirrors failed");
    }

    async function fetchPois(center, radiusMeters, selectedTypes, target){
      const { lat, lng } = center;
      const results = [];
      const seen = new Set();
      const order = ["shop","amenity","office","building","craft","leisure","tourism","healthcare","industrial"];
      const keys = order.filter(k => selectedTypes.includes(k)).concat(selectedTypes.filter(k => !order.includes(k)));

      for (const key of keys){
        const remaining = Math.max(0, target - results.length);
        if (remaining === 0) break;

        const limit = Math.min(remaining * 2, 300);
        const q = queryForKey(lat, lng, radiusMeters, key, limit);

        try{
          const data = await overpassCall(q);
          for (const el of (data.elements || [])){
            const y = el.lat || el.center?.lat;
            const x = el.lon || el.center?.lon;
            if (!y || !x) continue;

            const id = `${el.type || 'x'}:${el.id || 'x'}`;
            if (seen.has(id)) continue;

            const tags = el.tags || {};
            const street = tags["addr:street"] || "";
            const number = tags["addr:housenumber"] || "";
            const postal = (tags["addr:postcode"] || "").toString().trim().toUpperCase();

            // require full address + valid BE/NL postcode
            if (!street || !number || !postal) continue;
            if (!isValidBENLPostcode(postal)) continue;

            seen.add(id);
            results.push({ lat: y, lon: x, tags });
            updateStatus(`Collected ${results.length} / ${target}â€¦`);
            if (results.length >= target) return results; // early stop
          }
        }catch(e){
          console.warn("Overpass error on key", key, e);
        }
        await new Promise(r => setTimeout(r, 250));
      }
      return results;
    }

    // --- Sector from tags (for anonymized name category) ---
    function sectorFromTags(tags = {}) {
      const t = (s) => (s || "").toLowerCase();
      const shop = t(tags.shop), amen = t(tags.amenity), office = t(tags.office), craft = t(tags.craft),
            tourism = t(tags.tourism), leisure = t(tags.leisure), healthcare = t(tags.healthcare),
            industrial = t(tags.industrial), building = t(tags.building);
      if (["bakery","confectionery","pastry"].includes(shop)) return "Bakery";
      if (["bicycle"].includes(shop)) return "Bike Shop";
      if (["books","stationery"].includes(shop)) return "Bookstore";
      if (["pharmacy"].includes(shop) || amen==="pharmacy" || healthcare) return "Pharmacy";
      if (["computer","electronics","mobile_phone"].includes(shop)) return "Tech Store";
      if (["restaurant","fast_food","cafe"].includes(amen)) return "Restaurant";
      if (["bar","pub","biergarten"].includes(amen)) return "Bar";
      if (["fitness_centre","gym"].includes(amen)) return "Gym";
      if (["music","musical_instrument"].includes(shop)) return "Music Shop";
      if (["clothes","fashion_accessories","shoes"].includes(shop)) return "Clothing";
      if (craft) return "Workshop";
      if (tourism) return "Hotel";
      if (leisure) return "Leisure";
      if (industrial) return "Industrial";
      if (["retail","commercial","industrial"].includes(building)) return "Business";
      if (office) return "Office";
      return "Business";
    }

    // --- Main action (CSV: anonymized Name + address only) ---
    magicBtn.addEventListener('click', async () => {
      if (!marker) { alert("Please select a point first (click the map or search a city)."); return; }

      magicBtn.disabled = true;
      magicBtn.textContent = "Workingâ€¦ ðŸ§ ";
      updateStatus("Querying BE + NL places with valid postcodesâ€¦");

      try {
        const center = marker.getLatLng();
        const radiusMeters = kmToMeters(parseInt(radiusSlider.value, 10));
        const target = parseInt(countSlider.value, 10);
        const selectedTypes = getSelectedTypes();

        const source = await fetchPois(center, radiusMeters, selectedTypes, target);

        if (!source.length) {
          updateStatus("No BE/NL places with valid postcodes found here.");
          alert("No places found (BE/NL with valid postcodes). Try a larger radius or different types.");
          return;
        }

        const rows = [["Business Name","Street","Number","Postal Code","City"]];
        const uniqueName = makeUniqueNameDispenser(); // ensures global uniqueness
        for (const p of source.slice(0, target)) {
          const tags = p.tags || {};
          const sector = sectorFromTags(tags);
          const fakeName = nextCreativeName(sector);
          const name = uniqueName(fakeName);

          const street = tags["addr:street"] || "";
          const number = tags["addr:housenumber"] || "";
          const postal = (tags["addr:postcode"] || "").toString().trim().toUpperCase();
          const city   = getCityFromTags(tags);

          rows.push([name, street, number, postal, city]);
        }

        const csv = toCsv(rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url  = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "magic_addresses.csv";
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);

        updateStatus(`Done. Exported ${rows.length - 1} addresses.`);
        if (source.length < target) {
          alert(`Only ${rows.length - 1} addresses found with valid BE/NL postcodes (requested ${target}). Try increasing radius or selecting more types.`);
        }

      } catch (err) {
        console.error(err);
        updateStatus("Error while fetching addresses.");
        alert("Overpass seems busy or blocked. Please retry, change types, or increase the radius.");
      } finally {
        magicBtn.disabled = false;
        magicBtn.textContent = "Let's do the magic !";
      }
    });

    // --- Unique name wrapper (suffix if collision) ---
    function makeUniqueNameDispenser(){
      const used = new Set();
      return function(uniqueBase){
        let name = uniqueBase, i = 2;
        while(used.has(name)){
          name = uniqueBase + " " + i + " " + pick(["Ltd.","Inc.","Co.","Group","Studio","Works"]);
          i++;
        }
        used.add(name);
        return name;
      };
    }
  </script>
</body>
</html>
