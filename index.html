<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Magic Address Finder</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { font-family: Arial, sans-serif; margin:0; }
    #map { height: 460px; }
    .controls { padding:12px; display:grid; gap:10px; background:#f7f7f9; border-bottom:1px solid #e5e5ef; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row.wrap { align-items:flex-start; }
    label { font-weight:600; }
    input[type=text]{ padding:8px; min-width:260px; }
    input[type=range]{ width:280px; }
    .value{ font-weight:700; margin-left:6px; min-width:40px; text-align:right; }
    button{ padding:10px 16px; font-size:16px; cursor:pointer; border-radius:8px; border:1px solid #cfd2dc; background:white; }
    button:hover{ background:#f0f2f7; }
    .hint{ font-size:12px; color:#666; }
    .status { font-size:12px; color:#333; }
    .checkboxes { display:grid; grid-template-columns:repeat(4,minmax(140px,1fr)); gap:6px 16px; }
    .checkboxes label { font-weight:500; display:flex; gap:6px; align-items:center; }
    .section-title { font-weight:700; margin-right:6px; }
    .type-actions { display:flex; gap:8px; }
  </style>
</head>
<body>
  <div class="controls">
    <div class="row">
      <label for="cityInput">Search for a city:</label>
      <input type="text" id="cityInput" placeholder="Type a city..." />
      <button id="searchBtn">Search</button>
      <span class="hint">Tip: you can also click the map to set the point.</span>
    </div>

    <div class="row">
      <label for="radiusSlider">Radius (km):</label>
      <input type="range" id="radiusSlider" min="10" max="200" step="5" value="50" />
      <span class="value" id="radiusValue">50</span>
    </div>

    <div class="row">
      <label for="countSlider">Number of addresses:</label>
      <input type="range" id="countSlider" min="5" max="600" step="5" value="50" />
      <span class="value" id="countValue">50</span>
    </div>

    <div class="row wrap">
      <span class="section-title">Types:</span>
      <div class="checkboxes" id="typeChecks">
        <label><input type="checkbox" value="shop" checked />shop</label>
        <label><input type="checkbox" value="amenity" checked />amenity</label>
        <label><input type="checkbox" value="office" checked />office</label>
        <label><input type="checkbox" value="craft" checked />craft</label>
        <label><input type="checkbox" value="tourism" checked />tourism</label>
        <label><input type="checkbox" value="leisure" checked />leisure</label>
        <label><input type="checkbox" value="healthcare" checked />healthcare</label>
        <label><input type="checkbox" value="industrial" checked />industrial</label>
        <label><input type="checkbox" value="building" checked />building (retail/commercial/industrial)</label>
      </div>
      <div class="type-actions">
        <button id="btnAll">Select all</button>
        <button id="btnNone">Unselect all</button>
      </div>
    </div>

    <div class="row">
      <button id="magicBtn">Let's do the magic !</button>
    </div>

    <div class="status" id="status"></div>
    <div class="hint">Free data: OpenStreetMap via Overpass (multi-mirrors). Only POIs with addr:* (no reverse).</div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // --- Overpass mirrors ---
    const OVERPASS_ENDPOINTS = [
      "https://overpass.kumi.systems/api/interpreter",
      "https://overpass-api.de/api/interpreter",
      "https://overpass.openstreetmap.ru/api/interpreter",
      "https://overpass.nchc.org.tw/api/interpreter",
      "https://maps.mail.ru/osm/tools/overpass/api/interpreter"
    ];

    // --- Map init ---
    const map = L.map('map').setView([50.85, 4.35], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap contributors' }).addTo(map);

    let marker = null, circle = null, lastCityText = "", cancelRun = false;

    const cityInput   = document.getElementById('cityInput');
    const searchBtn   = document.getElementById('searchBtn');
    const radiusSlider= document.getElementById('radiusSlider');
    const radiusValue = document.getElementById('radiusValue');
    const countSlider = document.getElementById('countSlider');
    const countValue  = document.getElementById('countValue');
    const magicBtn    = document.getElementById('magicBtn');
    const statusEl    = document.getElementById('status');
    const typeChecks  = document.getElementById('typeChecks');
    const btnAll      = document.getElementById('btnAll');
    const btnNone     = document.getElementById('btnNone');

    const kmToMeters = km => km * 1000;

    function drawCircle(centerLatLng) {
      const radiusMeters = kmToMeters(parseInt(radiusSlider.value, 10));
      if (circle) circle.remove();
      circle = L.circle(centerLatLng, { radius: radiusMeters, color: "#2563eb", fillOpacity: 0.08 }).addTo(map);
      map.fitBounds(circle.getBounds(), { padding: [20,20] });
    }
    function setPoint(latlng){ if (marker) marker.remove(); marker = L.marker(latlng).addTo(map); drawCircle(latlng); }
    map.on('click', e => setPoint(e.latlng));
    radiusSlider.addEventListener('input', () => { radiusValue.textContent = radiusSlider.value; if (marker) drawCircle(marker.getLatLng()); });
    countSlider .addEventListener('input', () => { countValue.textContent  = countSlider.value; });

    // Select all / none
    btnAll.addEventListener('click', () => {
      typeChecks.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = true);
    });
    btnNone.addEventListener('click', () => {
      typeChecks.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = false);
    });

    // City search just for centering
    async function searchCity(){
      const q = cityInput.value.trim(); if(!q){ alert("Please type a city."); return; }
      try{
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
        const data = await res.json();
        if(data && data.length>0){ const lat=+data[0].lat, lon=+data[0].lon; setPoint([lat,lon]); lastCityText=q; }
        else alert("City not found. Click on the map instead.");
      }catch{ alert("Search failed. Click on the map instead."); }
    }
    searchBtn.addEventListener('click', searchCity);
    cityInput.addEventListener('keydown', e => { if(e.key==='Enter') searchCity(); });

    // --- CSV helper
    function toCsv(rows){
      const esc=v=>{ const s=String(v??""); return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s; };
      return rows.map(r=>r.map(esc).join(",")).join("\n");
    }
    function updateStatus(msg){ statusEl.textContent = msg; }

    // --- Build & run Overpass queries with LIMIT + EARLY-STOP ---------------
    function getSelectedTypes(){
      return Array.from(typeChecks.querySelectorAll("input[type=checkbox]"))
        .filter(cb => cb.checked).map(cb => cb.value);
    }

    function queryForKey(lat, lon, radiusMeters, key, limit){
      const R = Math.floor(radiusMeters);
      const LIM = Math.max(1, Math.min(300, limit|0));
      if (key === "building") {
        return `
          [out:json][timeout:60];
          (
            nwr(around:${R},${lat},${lon})["building"~"^(retail|commercial|industrial)$"]["addr:street"]["addr:housenumber"];
          );
          out tags center qt ${LIM};
        `;
      }
      return `
        [out:json][timeout:60];
        (
          nwr(around:${R},${lat},${lon})["${key}"]["addr:street"]["addr:housenumber"];
        );
        out tags center qt ${LIM};
      `;
    }

    async function overpassCall(query){
      const body = "data=" + encodeURIComponent(query);
      let lastErr;
      for (let i=0;i<OVERPASS_ENDPOINTS.length;i++){
        const ep = OVERPASS_ENDPOINTS[i];
        try{
          const res = await fetch(ep, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" },
            body
          });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return await res.json();
        }catch(e){
          lastErr = e;
          await new Promise(r => setTimeout(r, 500 * (i+1)));
        }
      }
      throw lastErr || new Error("All Overpass mirrors failed");
    }

    async function fetchPois(center, radiusMeters, selectedTypes, target){
      const { lat, lng } = center;
      const results = [];
      const seen = new Set();
      const order = ["shop","amenity","office","building","craft","leisure","tourism","healthcare","industrial"];
      const keys = order.filter(k => selectedTypes.includes(k)).concat(selectedTypes.filter(k => !order.includes(k)));

      for (const key of keys){
        const remaining = Math.max(0, target - results.length);
        if (remaining === 0) break;

        const limit = Math.min(remaining * 2, 300);
        const q = queryForKey(lat, lng, radiusMeters, key, limit);

        try{
          const data = await overpassCall(q);
          for (const el of (data.elements || [])){
            const y = el.lat || el.center?.lat;
            const x = el.lon || el.center?.lon;
            if (!y || !x) continue;
            const id = `${el.type || 'x'}:${el.id || 'x'}`;
            if (seen.has(id)) continue;
            seen.add(id);
            results.push({ lat: y, lon: x, tags: el.tags || {} });
            updateStatus(`Collected ${results.length} / ${target}â€¦`);
            if (results.length >= target) return results; // early stop
          }
        }catch(e){
          console.warn("Overpass error on key", key, e);
        }
        await new Promise(r => setTimeout(r, 250));
      }
      return results;
    }

    // --- Main action --------------------------------------------------------
    magicBtn.addEventListener('click', async () => {
      if (!marker) { alert("Please select a point first (click the map or search a city)."); return; }

      magicBtn.disabled = true;
      magicBtn.textContent = "Workingâ€¦ ðŸ§ ";
      updateStatus("Querying places with addressesâ€¦");

      try {
        const center = marker.getLatLng();
        const radiusMeters = kmToMeters(parseInt(radiusSlider.value, 10));
        const target = parseInt(countSlider.value, 10);
        const selectedTypes = getSelectedTypes();

        const source = await fetchPois(center, radiusMeters, selectedTypes, target);

        if (!source.length) {
          updateStatus("No places with explicit addresses found here.");
          alert("No places with explicit addresses found. Try a larger radius or different types.");
          return;
        }

        // Build CSV (Name + address only)
        const rows = [["Name","Street","Number","Postal Code","City"]];
        for (const p of source.slice(0, target)) {
          const tags = p.tags || {};
          const name = tags.name || tags.brand || "Unknown";
          const street = tags["addr:street"] || "";
          const number = tags["addr:housenumber"] || "";
          const postal = tags["addr:postcode"] || "";
          const city   = tags["addr:city"] || lastCityText || "";
          rows.push([name, street, number, postal, city]);
        }

        const csv = toCsv(rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url  = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "magic_addresses.csv";
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);

        updateStatus(`Done. Exported ${rows.length - 1} addresses.`);
        if (source.length < target) {
          alert(`Only ${source.length} places with full addresses found (requested ${target}). Increase radius or select more types.`);
        }

      } catch (err) {
        console.error(err);
        updateStatus("Error while fetching addresses.");
        alert("Overpass seems busy or blocked. Please retry, change types, or increase the radius.");
      } finally {
        magicBtn.disabled = false;
        magicBtn.textContent = "Let's do the magic !";
      }
    });
  </script>
</body>
</html>
