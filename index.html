<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Magic Address Finder</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { font-family: Arial, sans-serif; margin:0; }
    #map { height: 460px; }
    .controls { padding:12px; display:grid; gap:10px; background:#f7f7f9; border-bottom:1px solid #e5e5ef; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .row.wrap { align-items:flex-start; }
    label { font-weight:600; }
    input[type=text]{ padding:8px; min-width:260px; }
    input[type=range]{ width:280px; }
    .value{ font-weight:700; margin-left:6px; min-width:40px; text-align:right; }
    button{ padding:10px 16px; font-size:16px; cursor:pointer; border-radius:8px; border:1px solid #cfd2dc; background:white; }
    button:hover{ background:#f0f2f7; }
    .hint{ font-size:12px; color:#666; }
    .status { font-size:12px; color:#333; }
    .checkboxes { display:grid; grid-template-columns:repeat(4,minmax(140px,1fr)); gap:6px 16px; }
    .checkboxes label { font-weight:500; display:flex; gap:6px; align-items:center; }
    .section-title { font-weight:700; margin-right:6px; }
    .type-actions { display:flex; gap:8px; }
  </style>
</head>
<body>
  <div class="controls">
    <div class="row">
      <label for="cityInput">Search for a city:</label>
      <input type="text" id="cityInput" placeholder="Type a city..." />
      <button id="searchBtn">Search</button>
      <span class="hint">Tip: you can also click the map to set the point.</span>
    </div>

    <div class="row">
      <label for="radiusSlider">Radius (km):</label>
      <input type="range" id="radiusSlider" min="10" max="200" step="5" value="50" />
      <span class="value" id="radiusValue">50</span>
    </div>

    <div class="row">
      <label for="countSlider">Number of addresses:</label>
      <input type="range" id="countSlider" min="5" max="600" step="5" value="50" />
      <span class="value" id="countValue">50</span>
    </div>

    <div class="row wrap">
      <span class="section-title">Types:</span>
      <div class="checkboxes" id="typeChecks">
        <label><input type="checkbox" value="shop" checked />shop</label>
        <label><input type="checkbox" value="amenity" checked />amenity</label>
        <label><input type="checkbox" value="office" checked />office</label>
        <label><input type="checkbox" value="craft" checked />craft</label>
        <label><input type="checkbox" value="tourism" checked />tourism</label>
        <label><input type="checkbox" value="leisure" checked />leisure</label>
        <label><input type="checkbox" value="healthcare" checked />healthcare</label>
        <label><input type="checkbox" value="industrial" checked />industrial</label>
        <label><input type="checkbox" value="building" checked />building (retail/commercial/industrial)</label>
      </div>
      <div class="type-actions">
        <button id="btnAll">Select all</button>
        <button id="btnNone">Unselect all</button>
      </div>
    </div>

    <div class="row">
      <button id="magicBtn">Let's do the magic !</button>
    </div>

    <div class="status" id="status"></div>
    <div class="hint">Free data: OpenStreetMap via Overpass (multi-mirrors). Only POIs with addr:* (no reverse).</div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // --- Overpass mirrors ---
    const OVERPASS_ENDPOINTS = [
      "https://overpass.kumi.systems/api/interpreter",
      "https://overpass-api.de/api/interpreter",
      "https://overpass.openstreetmap.ru/api/interpreter",
      "https://overpass.nchc.org.tw/api/interpreter",
      "https://maps.mail.ru/osm/tools/overpass/api/interpreter"
    ];

    // --- Map init ---
    const map = L.map('map').setView([50.85, 4.35], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap contributors' }).addTo(map);

    let marker = null, circle = null, lastCityText = "", cancelRun = false;

    const cityInput   = document.getElementById('cityInput');
    const searchBtn   = document.getElementById('searchBtn');
    const radiusSlider= document.getElementById('radiusSlider');
    const radiusValue = document.getElementById('radiusValue');
    const countSlider = document.getElementById('countSlider');
    const countValue  = document.getElementById('countValue');
    const magicBtn    = document.getElementById('magicBtn');
    const statusEl    = document.getElementById('status');
    const typeChecks  = document.getElementById('typeChecks');
    const btnAll      = document.getElementById('btnAll');
    const btnNone     = document.getElementById('btnNone');

    const kmToMeters = km => km * 1000;

    function drawCircle(centerLatLng) {
      const radiusMeters = kmToMeters(parseInt(radiusSlider.value, 10));
      if (circle) circle.remove();
      circle = L.circle(centerLatLng, { radius: radiusMeters, color: "#2563eb", fillOpacity: 0.08 }).addTo(map);
      map.fitBounds(circle.getBounds(), { padding: [20,20] });
    }
    function setPoint(latlng){ if (marker) marker.remove(); marker = L.marker(latlng).addTo(map); drawCircle(latlng); }
    map.on('click', e => setPoint(e.latlng));
    radiusSlider.addEventListener('input', () => { radiusValue.textContent = radiusSlider.value; if (marker) drawCircle(marker.getLatLng()); });
    countSlider .addEventListener('input', () => { countValue.textContent  = countSlider.value; });

    // Select all / none
    btnAll.addEventListener('click', () => {
      typeChecks.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = true);
    });
    btnNone.addEventListener('click', () => {
      typeChecks.querySelectorAll('input[type=checkbox]').forEach(cb => cb.checked = false);
    });

    // City search just for centering
    async function searchCity(){
      const q = cityInput.value.trim(); if(!q){ alert("Please type a city."); return; }
      try{
        const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`);
        const data = await res.json();
        if(data && data.length>0){ const lat=+data[0].lat, lon=+data[0].lon; setPoint([lat,lon]); lastCityText=q; }
        else alert("City not found. Click on the map instead.");
      }catch{ alert("Search failed. Click on the map instead."); }
    }
    searchBtn.addEventListener('click', searchCity);
    cityInput.addEventListener('keydown', e => { if(e.key==='Enter') searchCity(); });

    // --- Creative Names Engine ------------------------------------------------
    const SUFFIXES = ["Ltd.","Inc.","Co.","Group","Studio","Works","Collective","Company","House","Lab","Atelier"];
    const ANIMALS  = ["Fox","Bear","Wolf","Otter","Hawk","Sparrow","Raven","Falcon","Deer","Bison","Lynx","Badger","Hare","Bee","Wasp","Crane","Heron","Puffin","Seal","Dolphin"];
    const NUMWORDS = ["Two","Three","Five","Seven","Nine","Twelve","Fifteen","Twenty"];
    const COLORS   = ["Blue","Green","Crimson","Amber","Ivory","Indigo","Golden","Silver","Copper","Emerald","Azure","Scarlet","Violet","Teal","Cobalt"];
    const QUALS    = ["Urban","Northern","Grand","Quiet","Happy","Sunny","Clever","Brisk","Rapid","Mighty","Honest","True","Brave","Nimble","Prime"];

    // Sector-specific lexicons (cores + alt suffixes)
    const LEX = {
      "Bakery": { cores:["Loaf","Crust","Oven","Pastry","Brioche","Bagel","Bakehouse","Bun","Mill","Flour","Yeast","Butter","Crumble","Croissant","Cracker"], ends:["Bakery","Bakehouse","Patisserie"] },
      "Bike Shop": { cores:["Cycle","Wheel","Spoke","Chain","Sprocket","Pedal","Frame","Saddle","Gear","Velodrome","Cruiser","Fixie","Trail","Gravel","Hub"], ends:["Cycles","Bicycles","Bike Co."] },
      "Bookstore": { cores:["Page","Chapter","Quill","Scroll","Library","Archive","Tome","Novel","Fable","Ink","Bookmark","Shelf","Edition","Folio","Volume"], ends:["Books","Bookshop","Press"] },
      "Pharmacy": { cores:["Health","Remedy","Cure","Vial","Herb","Pill","Care","Vital","Wellness","Apothecary","Hygieia","Ointment","Serum","Dose","Clinic"], ends:["Pharmacy","Apothecary","Health"] },
      "Tech Store": { cores:["Pixel","Circuit","Quantum","Logic","Byte","Chip","Matrix","Vector","Nova","Photon","Cloud","Kernel","Server","Console","Module"], ends:["Labs","Tech","Systems"] },
      "Restaurant": { cores:["Fork","Spoon","Skillet","Grill","Flame","Garden","Olive","Basil","Harvest","Pantry","Table","Cellar","Spice","Smoke","Ember"], ends:["Kitchen","Bistro","Table"] },
      "Bar": { cores:["Taproom","Barrel","Malt","Hop","Cask","Cellar","Stout","Ale","Wine","Tavern","Moon","Oak","Spirit","Lime","Salt"], ends:["Bar","Tavern","Club"] },
      "Gym": { cores:["Muscle","Core","Pulse","Sprint","Power","Iron","Fit","Motion","Tempo","Zen","Focus","Arena","Peak","Summit","Forge"], ends:["Gym","Fitness","Athletics"] },
      "Music Shop": { cores:["Note","Chord","Melody","Rhythm","Groove","Harmony","Lyric","Tempo","Beat","Vibe","Record","Vinyl","Guitar","Piano","Drum"], ends:["Music","Records","Sound"] },
      "Clothing": { cores:["Thread","Loom","Needle","Silk","Denim","Wool","Cotton","Wardrobe","Closet","Button","Pattern","Tailor","Stitch","Hem","Lace"], ends:["Apparel","Outfitters","Clothiers"] },
      "Workshop": { cores:["Workbench","Anvil","Forge","Hammer","Lathe","Chisel","Timber","Joinery","Panel","Resin","Fiber","Craft","Toolbox","Bench","Workshop"], ends:["Works","Atelier","Fabrication"] },
      "Hotel": { cores:["Harbor","Harbour","Vista","Garden","Cedar","Maple","Riverside","Lakeside","Hilltop","Crescent","Orchid","Aurora","Lagoon","Beacon","Lodge"], ends:["Hotel","Inn","Suites"] },
      "Leisure": { cores:["Arcade","Arena","Park","Playhouse","Meadow","Pavilion","Carousel","Bowling","Cinema","Skate","Rink","Lagoon","Pier","Boardwalk","Aquarium"], ends:["Leisure","Center","Park"] },
      "Industrial": { cores:["Steel","Foundry","Alloy","Forge","Engine","Turbine","Assembly","Terminal","Depot","Pipeline","Granite","Atlas","Crane","Anchor","Harbor"], ends:["Industries","Works","Plant"] },
      "Office": { cores:["Summit","Bridge","Harbor","Axis","Vista","Prime","Union","Pioneer","Anchor","Beacon","Cedar","Maple","Elm","Orchard","Sterling"], ends:["Office","Partners","Group"] },
      "Business": { cores:["Corner","Market","Square","Harbor","Harbour","Union","Central","Prime","Anchor","Bridge","Compass","Atlas","Pioneer","Crown","Crescent"], ends:["Company","Group","Co."] }
    };

    // Create 100 creative names per sector with patterns, then shuffle
    const NAME_POOLS = {};
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }

    function generatePoolFor(sector, target=100){
      const spec = LEX[sector] || LEX["Business"];
      const out = new Set();
      while(out.size < target){
        const form = Math.floor(Math.random()*6); // 6 patterns
        const adj = pick([...COLORS, ...QUALS]);
        const animal = pick(ANIMALS);
        const core1 = pick(spec.cores);
        const core2 = pick(spec.cores.filter(c => c!==core1));
        const end = pick(spec.ends);
        const num = pick(NUMWORDS);

        let name = "";
        switch(form){
          case 0: name = `${adj} ${core1} ${end}`; break;
          case 1: name = `${animal} ${core1} ${end}`; break;
          case 2: name = `${num} ${core1} ${end}`; break;
          case 3: name = `${core1} & ${core2} ${end}`; break;
          case 4: name = `${adj} ${animal} ${core1} ${end}`; break;
          case 5: name = `${core1} ${adj} ${end}`; break;
        }
        out.add(name.replace(/\s+/g,' ').trim());
      }
      return shuffle([...out]);
    }
    function getNamePool(sector){
      if(!NAME_POOLS[sector]) NAME_POOLS[sector] = generatePoolFor(sector, 100);
      return NAME_POOLS[sector];
    }

    // Unique name dispenser (global uniqueness across sectors)
    function makeUniqueNameDispenser(){
      const used = new Set();
      return function nextName(sector){
        const pool = getNamePool(sector);
        while(pool.length){
          const n = pool.pop();
          if(!used.has(n)){ used.add(n); return n; }
        }
        // Pool exhausted: fallback to combinatorial + suffix
        let base = `${pick(COLORS)} ${pick(LEX[sector]?.cores || LEX["Business"].cores)} ${pick(LEX[sector]?.ends || LEX["Business"].ends)}`;
        let i=2, candidate=base;
        while(used.has(candidate)){
          candidate = `${base} ${i} ${pick(SUFFIXES)}`;
          i++;
        }
        used.add(candidate);
        return candidate;
      };
    }
    const nextCreativeName = makeUniqueNameDispenser();

    // --- Helpers (CSV, etc.) -----------------------------------------------
    function toCsv(rows){
      const esc=v=>{ const s=String(v??""); return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s; };
      return rows.map(r=>r.map(esc).join(",")).join("\n");
    }
    function updateStatus(msg){ statusEl.textContent = msg; }

    // --- Build & run Overpass queries with LIMIT + EARLY-STOP ---------------
    function getSelectedTypes(){
      return Array.from(typeChecks.querySelectorAll("input[type=checkbox]"))
        .filter(cb => cb.checked).map(cb => cb.value);
    }
    function queryForKey(lat, lon, radiusMeters, key, limit){
      const R = Math.floor(radiusMeters);
      const LIM = Math.max(1, Math.min(300, limit|0));
      if (key === "building") {
        return `
          [out:json][timeout:60];
          (
            nwr(around:${R},${lat},${lon})["building"~"^(retail|commercial|industrial)$"]["addr:street"]["addr:housenumber"];
          );
          out tags center qt ${LIM};
        `;
      }
      return `
        [out:json][timeout:60];
        (
          nwr(around:${R},${lat},${lon})["${key}"]["addr:street"]["addr:housenumber"];
        );
        out tags center qt ${LIM};
      `;
    }
    async function overpassCall(query){
      const body = "data=" + encodeURIComponent(query);
      let lastErr;
      for (let i=0;i<OVERPASS_ENDPOINTS.length;i++){
        const ep = OVERPASS_ENDPOINTS[i];
        try{
          const res = await fetch(ep, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8" }, body });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return await res.json();
        }catch(e){
          lastErr = e;
          await new Promise(r => setTimeout(r, 500 * (i+1)));
        }
      }
      throw lastErr || new Error("All Overpass mirrors failed");
    }
    async function fetchPois(center, radiusMeters, selectedTypes, target){
      const { lat, lng } = center;
      const results = [];
      const seen = new Set();
      const order = ["shop","amenity","office","building","craft","leisure","tourism","healthcare","industrial"];
      const keys = order.filter(k => selectedTypes.includes(k)).concat(selectedTypes.filter(k => !order.includes(k)));

      for (const key of keys){
        if (cancelRun) break;
        const remaining = Math.max(0, target - results.length);
        if (remaining === 0) break;

        const limit = Math.min(remaining * 2, 300);
        const q = queryForKey(lat, lng, radiusMeters, key, limit);

        try{
          const data = await overpassCall(q);
          for (const el of (data.elements || [])){
            if (cancelRun) break;
            const y = el.lat || el.center?.lat;
            const x = el.lon || el.center?.lon;
            if (!y || !x) continue;
            const id = `${el.type || 'x'}:${el.id || 'x'}`;
            if (seen.has(id)) continue;
            seen.add(id);
            results.push({ lat: y, lon: x, tags: el.tags || {} });
            updateStatus(`Collected ${results.length} / ${target}â€¦`);
            if (results.length >= target) return results; // EARLY STOP
          }
        }catch(e){
          console.warn("Overpass error on key", key, e);
        }
        await new Promise(r => setTimeout(r, 250));
      }
      return results;
    }

    // --- Sector from tags (for name lexicon selection) ----------------------
    function sectorFromTags(tags = {}) {
      const t = (s) => (s || "").toLowerCase();
      const shop = t(tags.shop), amen = t(tags.amenity), office = t(tags.office), craft = t(tags.craft),
            tourism = t(tags.tourism), leisure = t(tags.leisure), healthcare = t(tags.healthcare),
            industrial = t(tags.industrial), building = t(tags.building);
      if (["bakery","confectionery","pastry"].includes(shop)) return "Bakery";
      if (["bicycle"].includes(shop)) return "Bike Shop";
      if (["books","stationery"].includes(shop)) return "Bookstore";
      if (["pharmacy"].includes(shop) || amen==="pharmacy" || healthcare) return "Pharmacy";
      if (["computer","electronics","mobile_phone"].includes(shop)) return "Tech Store";
      if (["restaurant","fast_food","cafe"].includes(amen)) return "Restaurant";
      if (["bar","pub","biergarten"].includes(amen)) return "Bar";
      if (["fitness_centre","gym"].includes(amen)) return "Gym";
      if (["music","musical_instrument"].includes(shop)) return "Music Shop";
      if (["clothes","fashion_accessories","shoes"].includes(shop)) return "Clothing";
      if (craft) return "Workshop";
      if (tourism) return "Hotel";
      if (leisure) return "Leisure";
      if (industrial) return "Industrial";
      if (["retail","commercial","industrial"].includes(building)) return "Business";
      if (office) return "Office";
      return "Business";
    }

    function sampleArray(arr, n){
      if (arr.length <= n) return [...arr];
      const res=[]; const used = new Set();
      while(res.length<n){
        const i = Math.floor(Math.random()*arr.length);
        if(!used.has(i)){ used.add(i); res.push(arr[i]); }
      }
      return res;
    }

    // --- Main action --------------------------------------------------------
    magicBtn.addEventListener('click', async () => {
      if (!marker) { alert("Please select a point first (click the map or search a city)."); return; }

      cancelRun = false;
      magicBtn.disabled = true;
      magicBtn.textContent = "Workingâ€¦ ðŸ§ ";
      updateStatus("Querying places with addressesâ€¦");

      try {
        const center = marker.getLatLng();
        const radiusMeters = kmToMeters(parseInt(radiusSlider.value, 10));
        const target = parseInt(countSlider.value, 10);
        const selectedTypes = getSelectedTypes();

        const source = await fetchPois(center, radiusMeters, selectedTypes, target);

        if (!source.length) {
          updateStatus("No places with explicit addresses found here.");
          alert("No places with explicit addresses found. Try a larger radius or different types.");
          return;
        }

        const picked = sampleArray(source, Math.min(target, source.length));
        updateStatus(`Preparing ${picked.length} addressesâ€¦`);

        const rows = [["Business Name","Street","Number","Postal Code","City","Latitude","Longitude"]];
        for (const p of picked) {
          const sector = sectorFromTags(p.tags);
          const fakeName = nextCreativeName(sector);
          const addr = {
            street: p.tags["addr:street"] || "",
            number: p.tags["addr:housenumber"] || "",
            postal: p.tags["addr:postcode"] || "",
            city:   p.tags["addr:city"] || lastCityText || ""
          };
          rows.push([
            fakeName, addr.street, addr.number, addr.postal, addr.city,
            (+p.lat).toFixed(6), (+p.lon).toFixed(6)
          ]);
        }

        const csv = toCsv(rows);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url  = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = "magic_addresses.csv";
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
        URL.revokeObjectURL(url);

        updateStatus(`Done. Exported ${rows.length - 1} addresses.`);
        if (picked.length < target) {
          alert(`Only ${picked.length} places with full addresses found (requested ${target}). Increase radius or select more types.`);
        }

      } catch (err) {
        console.error(err);
        updateStatus("Error while fetching addresses.");
        alert("Overpass seems busy or blocked. Please retry, change types, or increase the radius.");
      } finally {
        magicBtn.disabled = false;
        magicBtn.textContent = "Let's do the magic !";
        cancelRun = false;
      }
    });
  </script>
</body>
</html>
